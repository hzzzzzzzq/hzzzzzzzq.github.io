[{"title":"ES 6 系列之Module 语法","url":"/2022/01/18/Blog-ES-6-12-Module-语法/","content":"\n## 概述\n\n在 ES 6 之前，社区制定了一些模块加载方案，最主要的就是 [`CommonJS`]() 和 AMD 两种。前者主要用于服务器，后者用于浏览器。ES 6 在语言层面上实现了模块功能，可以取代 [`CommonJS`]() 和 AMD 规范，成为了通用的模块解决方案。\n\n## 基本使用\n\n`module` 主要由 `export` 和 `import` 两个命令。`export` 命令用于规定模块的对外接口，`import` 命令用于输入其他模块功能。\n每一个模块都是一个独立文件，文件内的所有变量，外部无法获取，如果希望在外部获取，就必须使用 `export` 命令进行输出。\n我们创建一个 `export.js` 文件，来写 `export` 相关内容，`import.js` 作为 `import` 导入相关内容。\n\n### export 命令\n\n先看看 `export` 命令的写法。\n\n```javascript\n// export.js\nexport const name = 'hzzzzzzzq';\nexport const age = 18;\nexport const height = 1.78;\n```\n\n上面是一种每一个都导出的写法，也可以看一下另外一种写法，使用一起导出的方式。\n\n```javascript\n// export.js\nconst name = 'hzzzzzzzq';\nconst age = 18;\nconst height = 1.78;\nexport { name, age, height };\n```\n\n两种写法是相同的。\n当然 export 命令肯定不只是只能导出变量，还可以导出函数或者类。\n来看看函数导出吧，还是用老朋友 `add` 来看吧。\n当然， function 和 class 的输出，必须使用这样的格式。\n\n```javascript\n// export.js\nexport function add(x, y) {\n  return x + y;\n}\n\n// 或者\nfunction add(x, y) {\n  return x + y;\n}\nexport { add };\n```\n\n在导出的时候，需要注意的是，**导出的变量必须与模块内部的变量建立一一对应关系**。\n\n### import 命令\n\n使用 `import` 命令导入 `export.js` 文件，然后打印。\n\n```javascript\n// import.js\nimport { name, age, height, add } from './export.js';\nconsole.log(name, age, height);\n// hzzzzzzzq 18 1.78\nconsole.log(add(1, 2)); // 3\n```\n\n如果想要自己重新命名，在 `import` 时，要使用 `as` 关键字，比如我将 `add` 改为 `sum`。\n\n```javascript\nimport { add as sum } from './export.js';\n```\n\n需要注意的是\n\n- `import` 命令具有提升效果，会提升到整个模块的顶部，首先执行。\n- `import` 是静态执行，不可以使用表达式或者变量\n- 多次重复执行同一句 `import` ，那么只会执行一次，不会多次执行。\n\n```javascript\nconsole.log(add(1, 2)); // 3\nimport { add } from './export.js';\nimport { name } from './export.js'; // 与上一句相同\n// 等同于\nimport { add, name } from './export.js'\n\nimport { 'a' + 'dd'} from './export.js'; // 报错\n```\n\n### 模块的整体加载\n\n导入时，除了一个一个的导入，还有一种整体导入方式，就是使用( `*` )来指定一个对象。\n\n我们来看看刚刚的全部导入方式。\n\n```javascript\nimport * as all from './export.js';\n\nconsole.log(all.name, all.age, all.height); // hzzzzzzzq 18 1.78\nconsole.log(all.add(1, 2)); // 3\n```\n\n这种方式，模块整体加载所在的那个对象，也就是 `all` 对象。\n\n### export default 命令\n\n导出还有一种 `export default` 命令，这种导出方式就是指定默认输出。\n\n```javascript\n// export.js\n// 例子 类\nexport default class () { ... }\n\n// 或者\n// 例子 函数\nexport function (x, y) {\n  return x + y;\n}\n```\n\n这种导出方式，不需要固定的名称，来对应，可以直接使用匿名类或匿名函数，也可以不用匿名，但是导出时，都是可以任意命名。\n\n导入时不需要使用 `{}` 来包裹，可以直接命名，使用任何名称命名导入。\n\n```javascript\n// 例子 类\nimport Obj from './export.js';\nlet obj = new Obj();\n\n// 或者\n// 例子 函数\nimport add from './export.js';\nconsole.log(add(1, 2));\n```\n\n## 总结\n\n在正常开发当中，最常使用的一些 `export` 、`improt` 以及一些 `export default` 的方法。\n","tags":["ES 6"],"categories":["ECMAScript 6"]},{"title":"ES 6 系列之Async/await","url":"/2022/01/18/Blog-ES-6-11-三种异步之async函数/","content":"\n## 介绍\n\n`async` 函数时什么，其实就是 `Generator` 的语法糖，只需要将 `*` 改写成 `async`，`yield` 改写成 `await`。\n我们来看看 `Generator` 的写法，与 `async` 的写法。\n\n```javascript\nconst readFile = function (fileName, ms) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(fileName);\n      resolve(fileName); // 需要给 `Promise` 一个状态转化，就是异步执行是否成功\n    }, ms);\n  });\n};\n\nfunction* genator() {\n  yield readFile('fileName1', 1000);\n  yield readFile('fileName2', 2000);\n  yield readFile('fileName3', 3000);\n  console.log('打印完毕');\n}\nconst gen = genator();\ngen.next(); // fileName1\ngen.next(); // fileName2\ngen.next(); // fileName3\n\nasync function asyncTest() {\n  await readFile('fileName1', 1000);\n  await readFile('fileName2', 2000);\n  await readFile('fileName3', 3000);\n  console.log('执行完毕');\n}\nasyncTest();\n// fileName1\n// fileName2\n// fileName3\n// 执行完毕\n```\n\n从上面我们可以看出，我们需要手动调用 `next` 方法，来执行下一步。\n而 `async` 有自己内置执行器。\n\n我们来看看 `async` 对 `Generator` 的改进。\n\n- 内置执行器\n  Generator 函数执行需要 `next` 执行器，外面手动调用，所以有 `co` 模块，而 async 函数自带执行器，与普通函数一样，只需要一行调用。\n  下面代码中，调用了该函数之后，就会自动执行，输出最后结果。\n\n```javascript\nasyncTest();\n```\n\n- 语义更好\n  `async/await`，比起 `Generator` 函数的 `*` 与 `yield`，语义更清晰。 `async` 就表示异步，而 `await` 表示后面的表达式需要等待结果。\n\n- 适用性更强\n  `co` 模块约定，`yield` 后面只能是 `Thunk` 函数或者 `Promise` 对象，而 `await` 后面可以是 `Promise`，也可以是原始类型值。\n\n- 返回值是 `Promise`\n  `async` 函数返回值是 `Promise` 对象，可以用 `then` 方法来进行下一步操作。\n  `await` 命令就是内部 `then` 命令的语法糖。\n\n## 用法\n\n### 返回 Promise 对象\n\n- `async` 函数返回一个 `Promise` 对象，可以使用 `then` 方法加入回调函数。\n- 执行函数时，遇到 `await` 就会先返回，等异步操作结束，再继续执行函数体后面的语句。\n- 必须等到内部所有 `await` 命令后面的 `Promise` 对象执行完毕，状态才会改变，除非遇到 `return` 或者报错。\n- `async` 函数内部的异步操作执行完毕，就可以执行 `then` 方法。\n- `JS` 没有休眠的语法，但是借助 `await` 命令就可以让程序停顿一定的时间。\n\n```javascript\nasync function useAsync() {\n  // readFile 使用的是本文顶部的方法\n  const result = await readFile('fileName', 1000);\n  return result;\n}\nuseAsync().then((value) => {\n  console.log(value);\n});\n// fileName\n// fileName\n```\n\n- 如果返回 `reject` 状态，则会中断执行，并通过 `catch` 捕获\n\n```javascript\nasync function useAsync() {\n  // readFile 使用的是本文顶部的方法\n  const result = await Promise.reject('测试错误');\n  console.log('打印？');\n  return result;\n}\nuseAsync()\n  .then((value) => {\n    console.log(value);\n  })\n  .catch((error) => {\n    console.log(error);\n  });\n// 测试错误\n```\n\n### await 命令\n\n`await` 命令后面是一个 `Promise` 对象，返回结果。如果不是 `Promise`，就直接返回对应值。\n\n- `await` 命令只能出现在 `async` 命令函数内部，不然会报错。\n\n```javascript\nconst add = (a, b) => {\n  return a + b;\n};\nasync function useAsync() {\n  const result = await add(1, 2);\n  return result;\n}\nuseAsync().then((value) => {\n  console.log(value);\n});\n// 3\n```\n\n`await` 后面跟着 `add` 方法，算出一个数值 `3`，然后将值 `return` 出来。\n\n---\n\n简单的 `await` 使用方法，就是如此。\n","tags":["ES 6"],"categories":["ECMAScript 6"]},{"title":"ES 6 系列之Generator 函数","url":"/2022/01/18/Blog-ES-6-10-三种异步之Generator函数/","content":"\n## 介绍\n\n`Generator` 是 `ES 6` 提供的一种异步编程解决方案。\n\n- 函数定义时，在 `funciton` 后面添加一个星号(`*`)\n- 函数体内部使用 `yield` 表达式\n\n```javascript\n// 普通函数\nfunction a() {}\n\n// Generator\nfunction* generator() {\n  yield 'hello';\n  yield 'hzzzzzzzq';\n  return 'good';\n}\n```\n\n`Generator` 函数的调用方式与普通函数是一样的，在函数名后面加上一对圆括号。\n\n### yield 表达式\n\n`yield` 表达式就是 `Generator` 的暂停标志。\n\n- 遇到 `yield` 表达式，就会停止执行后面的操作，`yield` 后面表达式的值，作为返回对象的 `value` 属性值\n- 下次调用 `next` 方法时，才会继续执行代码，直到下一个 `yield`\n- 如果没有遇到遇到 `yield`，则运行至结束，看是否有 `return`，如果有，则 `return` 后面的值作为返回对象的 `value`\n- 如果没有 `yield` 或 `return`，则返回 `value` 为 `undefined`\n\n```javascript\nfunction* generator() {\n  yield 'hello'; // 第一个 next 时，执行\n  yield 'hzzzzzzzq'; // 第二个 next 时，执行\n  return 'good'; // 第三个 next 时，执行\n}\n```\n\n在上面的代码中，我们可以来感受上面的用途。\n\n只有在调用 `next` 方法将指针移到这一句时，才会进行求值。\n\n与 `return` 不同的地方在于，`return` 不具备记忆功能，也就说，在一个函数中，`return` 只能执行一次，而 yield 具备记忆功能，可以通过 `next` 方法继续执行代码。\n\n## next 方法\n\n### next 普通使用\n\n`next` 方法就是 `generator` 函数的内置执行器，如果遇到 `yield` 时，只有通过调用 `next`，才会继续执行代码。\n\n而 `next` 代码的执行值，我们可以打印来看，会是一个对象，带有 `value` 和 `done` 两个属性。\n\n```javascript\nfunction* generator() {\n  yield 'hello';\n  yield 'hzzzzzzzq';\n  return 'good';\n}\n\nconst gen = generator();\nconsole.log(gen.next()); // { value: 'hello', done: false }\nconsole.log(gen.next()); // { value: 'hzzzzzzzq', done: false }\nconsole.log(gen.next()); // { value: 'good', done: true }\nconsole.log(gen.next()); // { value: undefined, done: true }\n```\n\n- `value` 值显示的是 `yield` 或者 `return` 后面的返回值。\n- `done` 是一个布尔值，表示遍历是否结束，`true` 表示结束。\n- 当然，`return` 只能有一个，且 `return` 之后不能有 `yield`，因为 `return`，就会让 `done` 变成 `true`。\n\n### next 方法参数\n\n`next` 方法可以带一个参数，**该参数会被当作上一个 `yield` 表达式的值**。\n\n```javascript\nfunction* generator() {\n  while (true) {\n    let value = yield null;\n    console.log(value);\n  }\n}\nconst gen = generator();\nconsole.log(gen.next());\nconsole.log(gen.next('world'));\n// { value: null, done: false }\n// world\n// { value: 'null', done: false }\n```\n\n当然，这个是会被当作上一个 `yield` 表达式的值，是在函数内部使用，并不是在 `next` 返回对象中作为 `value` 的键值返回。他会替换 `generator` 函数体内的上一个 `yield` 值并赋值给我们定义的变量 `value`。\n\n## for...of 循环\n\n`for...of` 循环可以自动遍历 `Generator` 函数运行时生成的 `Interator` 对象，不需要手动调用 `next` 方法。\n\n```javascript\nfunction* gen() {\n  yield 'one';\n  yield 'two';\n  yield 'three';\n  yield 'four';\n  return 'five';\n}\nfor (let v of gen()) {\n  console.log(v);\n}\n// one two three four\n```\n\n注意：如果 `done` 为 `true`，则会被立刻终止，所有最后一句 `return` 语句不在循环中。\n\n处理 `for...of` 循环之外，扩展运算符，解构赋值和 `Array.from` 方法内部调用的，都是遍历器接口。\n都可以将 `Generator` 函数作为返回的 `Interator` 对象，作为参数。\n\n```javascript\nfunction* gen() {\n  yield 'one';\n  yield 'two';\n  yield 'three';\n  yield 'four';\n  return 'five';\n}\nconsole.log([...gen()]);\n// ['one', 'two', 'three', 'four']\n\nconsole.log(Array.from(gen()));\n// ['one', 'two', 'three', 'four']\n\nlet [x, y, z] = gen();\nconsole.log(x, y, z);\n// one two three\n```\n\n## yield\\*\n\n`yield*` 就是 用来在一个 `Generator` 函数里面执行另一个 `Generator` 函数。\n\n```javascript\nfunction* generator1() {\n  yield 'hello';\n  yield 'hzzzzzzzq';\n  yield 'good';\n}\nfunction* generator() {\n  yield* generator1();\n}\nconst gen = generator();\nconsole.log(gen.next().value); // hello\nconsole.log(gen.next().value); // hzzzzzzzq\nconsole.log(gen.next().value); // good\nconsole.log(gen.next().value); // undefined\n```\n\n我们在 `generator` 函数中，使用了 `yield*` ，后面调用 `generator1` 函数。\n\n然后我们就可以直接使用 `next` 函数，跟普通的 `generator` 函数一样使用就可以。\n\n## Generator.prototype.throw() / return()\n\n### throw()\n\n`Generator` 函数返回的遍历器对象，都会有个 `throw` 方法，可以在函数体外抛出错误，然后在 `Generator` 函数体内捕获。\n\n```javascript\nfunction* generator() {\n  try {\n    yield 1;\n  } catch (e) {\n    console.log('内部', e);\n  }\n}\nlet gen = generator();\ngen.next();\ntry {\n  gen.throw('错误1');\n  gen.throw('错误2');\n} catch (e) {\n  console.log('外部', e);\n}\n// 内部 错误1\n// 外部 错误2\n```\n\n在上面的例子中，我们可以看出，第一个 `throw` 被函数体内部的 `catch` 语句捕获，然而第二个错误，在内部已经执行过 `catch`，所有这个错误就被抛出来了，被外面的 `try...catch` 捕获。\n\n### return()\n\n`Generator` 函数返回的对象中，还有一个 `return` 方法，可以返回给定的值，并且结束 `Generator` 函数。\n\n```javascript\nfunction* generator() {\n  yield 'hello';\n  yield 'hzzzzzzzq';\n  yield 'good';\n}\nconst gen = generator();\ngen.next(); // { value: 'hello', done: false }\ngen.return('world'); // { value: 'world', done: true }\ngen.next(); // { value: undefined, done: true }\n```\n\n从上面的例子，我们可以看出，执行 `return` 之后，后面的 `done` 就会变为 `true`，且传入的参数会作为返回对象的 `value` 值。\n\n在以后调用时，都会被调整为 `undefined`，其实就相当于，将 `generator` 函数中的添加一个 `return` 。\n\n## Generator 函数的异步操作\n\n我们使用一个 `readFile`，使用 `setTimeout` 假装调用接口，然后调用 `gen.next()` 接口返回对象的 `value` 属性值进行下一步操作。\n\n```javascript\nconst readFile = function (fileName, ms) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('异步请求成功回调'); // 需要给 `Promise` 一个状态转化，就是异步执行是否成功\n    }, ms);\n  });\n};\n\nfunction* generator() {\n  const str = yield readFile('fileName1', 1000);\n  console.log(str);\n}\nconst gen = generator();\nconst result = gen.next(); // fileName1\nresult.value\n  .then((val) => {\n    console.log(val);\n    return val;\n  })\n  .then((val2) => {\n    gen.next('异步请求结果');\n  });\n// 异步请求成功回调\n// 异步请求结果\n```\n\n`yield` 后面用来调用异步函数，然后返回结果输出。\n","tags":["ES 6"],"categories":["ECMAScript 6"]},{"title":"ES 6 系列之Promise 对象","url":"/2022/01/18/Blog-ES-6-9-三种异步之Promise-对象/","content":"\n## 含义\n\n**Promise 是异步编程的一种解决方案**，在 `Promise` 之前，采用的是回调函数和事件，但是会存在一些问题，像回调地狱。而在 ES6 中，提供了 `Promise` 对象。\n\n`Promise` 简单来讲，其实就是一个容器，用来存储异步事件（例如网络请求等）。\n\n语法上来说，`Promise` 是一个对象，可以获取异步操作的消息。\n\n### 主要特点\n\n- 对象状态不受外界影响。\n  - 一共只有三种状态：`pending` （进行中）、`fulfilled`（完成）和 `rejected`（失败）。只受异步操作的结果，可以决定当前是哪种状态，其他任何操作都无法改变这个状态。\n- 一旦状态改变，就不能再变，任何时候都可以得到这个结果。\n  - Promise 对象状态改变只有两种可能性，从`pending` 到 `fulfilled` 和从 `pending` 到 `rejected`。\n\n### 主要缺陷\n\n- 一旦创建会立即执行，无法中途取消。\n- 如果内部不设置回调函数，外部是不能知道内部情况的。\n- 当状态处于 `pending` 时，无法得知目前进展到哪个阶段。\n\n## 基本用法\n\n这里一般需要进行异步操作，但是为了学习方便，我们直接同步进行了。\n`Promise` 构造函数接受一个函数作为参数，该函数的参数为 `resolve` 和 `reject`。 `resolve` 和 `reject` 是两个函数，有 JS 引擎提供，不需要自己部署。\n`resolve` 函数作用是将 `Promise` 的状态从 `pending` 变为 `resolved`，并且将操作结果作为参数传递出去。\n`reject` 函数作用是将 `Promise` 的状态从 `pending` 变为 `rejected`，并且将错误信息传递出去。\n`Promise` 生成实例之后，可以调用 `then` 方法，其中包含两个函数参数。第一个函数包含 `resolved` 状态的结果，第二个包含 `rejected` 状态结果。两个函数都是可选参数。\n\n我们将 `flag` 比做异步操作，`true` 表示异步成功，`false` 表示异步失败。\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  let flag = true;\n  if (flag) {\n    resolve('操作成功');\n  } else {\n    reject('操作失败');\n  }\n});\npromise.then(\n  (value) => {\n    console.log('value = ', value);\n  },\n  (error) => {\n    console.log('error = ', error);\n  }\n);\n```\n\n从上面的代码来看，`flag` 为 `true` 时，会打印 `value = 操作成功`，为 false 时，打印 `error = 操作失败`。\n\n我们来看看 `then` 的异步。\n在 `Promise` 创建时，就会立即执行，而 `then` 会在当前脚本所有同步任务执行完才会执行。\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  console.log('1');\n  resolve('2');\n});\npromise.then((val) => {\n  console.log(val);\n});\nconsole.log('3');\n// '1'\n// '3'\n// '2'\n```\n\n## 实例方法\n\n### Promise.prototype.then()\n\n`Promise.prototype.then()` 方法作用是为 `Promise` 实例添加状态改变时的回调函数。\n`then` 方法的第一个参数是 `resolved` 状态的回调函数，第二个参数是 `rejected` 状态的回调函数，它们都是可选的值，不一定必须传入。\n\n`then` 方法返回的是一个新的 `Promise` 实例，所以可以采用链式写法。\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  resolve('1');\n});\npromise\n  .then((val) => {\n    return val;\n  })\n  .then((val) => {\n    console.log(val);\n  });\n// '1'\n```\n\n### Promise.prototype.catch()\n\n`Promise.prototype.catch()` 方法就是在 `then` 方法时 `reject` 的情况，用于发生错误时的回调函数。\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  reject('1');\n});\npromise.catch((error) => {\n  console.log(error);\n});\n// '1'\n```\n\n如果在 `Promise` 中报错，进行错误抛出，状态会变为 `rejected`，就会调用 `catch()` 方法指定的回调函数，然后在其中处理错误。\n\n当然，如果在运行过程中，抛出错误，也会被 `catch` 捕获。\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  throw new Error('Error');\n});\npromise.catch((error) => {\n  console.log(error);\n});\n// 'Error'\n```\n\n### Promise.prototype.finally()\n\n`Promise.prototype.finally()` 方法不管 `Promise` 对象最后状态如何，都会进行执行。\n\n```javascript\nconst promise1 = new Promise((resolve, reject) => {\n  resolve('成功');\n});\npromise1.finally(() => {\n  console.log('执行finally');\n});\n// 执行finally\nconst promise2 = new Promise((resolve, reject) => {\n  reject('失败');\n});\npromise2.finally(() => {\n  console.log('执行finally');\n});\n// 执行finally\n```\n\n## Promise 类方法\n\n### Promise.all()\n\n`Promise.all()` 方法可以将多个 `Promise` 实例，包装成一个新的 `Promise` 实例。\n\n- 多个 `Promise` 中，其中一个状态不是 `fulfilled`，p 的结果就不会是 `fulfilled`\n\n```javascript\nconst promise1 = new Promise((resolve, reject) => {\n  resolve('1');\n});\nconst promise2 = new Promise((resolve, reject) => {\n  resolve('2');\n});\nconst promise3 = new Promise((resolve, reject) => {\n  resolve('3');\n});\nconst promise = Promise.all([promise1, promise2, promise3]);\n\npromise.then((val) => {\n  console.log(val);\n});\n// ['1', '2', '3']\n```\n\n- 只要有一个状态变为 `rejected`，此时**第一个**被 `reject` 的实例的返回值，会被传递为 `promise` 的回调函数。\n\n```javascript\n// 我们将上面的代码其中一个 resolve 修改为 reject('1')\nconst promise3 = new Promise((resolve, reject) => {\n  reject('3');\n});\nconst promise = Promise.all([promise1, promise2, promise3]);\n\npromise.then(\n  (val) => {\n    console.log(val);\n  },\n  (error) => {\n    console.log(error); // 3\n  }\n);\n```\n\n### Promise.race()\n\n`Promise.race()` 方法同样是将多个实例包装为一个新的 `Promise` 实例。\n\n- 多个 `Promise` 时，哪一个率先改变状态，`promise` 的状态就跟着哪个改变。\n\n```javascript\nconst promise1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('1');\n  }, 1000);\n});\nconst promise2 = new Promise((resolve, reject) => {\n  resolve('2');\n});\nconst promise3 = new Promise((resolve, reject) => {\n  resolve('3');\n});\nconst promise = Promise.race([promise1, promise2, promise3]);\n\npromise.then((val) => {\n  console.log(val);\n});\n// 2\n```\n\n我们在第一个使用了 `setTimeout`，进行延迟，所以会是第二个的状态先改变，输出第二个的值。\n\n### Promsie.allSettled()\n\n`Promise.allSettled()` 方法，用来确定一组异步操作是否都结束了。\n数组的每个成员都是一个 Promise 对象，并返回一个新的 `Promise` 对象，只有数组中的 `Promsie` 对象状态都发生改变时，返回的 `Promise` 对象才发生改变。\n返回的值会接收到一个数组作为参数，该数组的每一个成员对应前面数组的每个 `Promise` 对象。\n\n```javascript\nconst promise1 = new Promise((resolve, reject) => {\n  reject('1');\n});\nconst promise2 = new Promise((resolve, reject) => {\n  resolve('2');\n});\nconst promise3 = new Promise((resolve, reject) => {\n  reject('3');\n});\nconst promise = Promise.allSettled([promise1, promise2, promise3]);\npromise.then(\n  (val) => {\n    console.log(val);\n  },\n  (error) => {\n    console.log(error);\n  }\n);\n// [\n//   {\n//     status: 'rejected',\n//     reason: '1',\n//   },\n//   {\n//     status: 'fulfilled',\n//     value: '2',\n//   },\n//   {\n//     status: 'rejected',\n//     reason: '3',\n//   },\n// ];\n```\n\n数组成员对象的 `status` 属性的值只可能是 `fulfilled` 或 `rejected`，用来区别异步操作结果是成功(`fulfilled`)还是失败(`rejected`)。\n如果是成功是会有 `value` 属性，记录成功值，如果失败，会有 `reason` 属性，记录失败原因。\n\n### Promise.any()\n\n`Promise.any()` 方法，将一组 `Promise` 实例作为参数，包装成一个新的 `Promise` 实例并返回。\n\n- 只要有一个变成 `fulfilled` 状态，新实例就会被包装成 `fulfilled` 状态\n- 如果所有参数实例都变成 `rejected` 状态，包装实例就会变成 `rejected` 状态\n\n```javascript\nconst promise1 = new Promise((resolve, reject) => {\n  reject('1');\n});\nconst promise2 = new Promise((resolve, reject) => {\n  resolve('2');\n});\nconst promise3 = new Promise((resolve, reject) => {\n  reject('error');\n});\nPromise.any([promise1, promise2, promise3])\n  .then((val) => {\n    // 只要有一个成功\n    console.log(val);\n  })\n  .catch((error) => {\n    console.log(error);\n  });\n// 2\n```\n\n### Promise.resolve()\n\n`Promise.resolve()` 方法有四种情况。\n\n```javascript\nconst promise = Promise.resolve('请求成功');\n// 等价于\nconst promise = new Promise((resolve) => resolve('请求成功'));\n```\n\n- 参数为 `Promise` 时，不做任何修改，直接返回这个实例。\n\n```javascript\nconst promise = new Promise((resolve) => resolve('请求成功'));\nconst promise1 = Promise.resolve(promise);\npromise1.then((val) => {\n  console.log(val);\n});\n```\n\n- 参数是 `thenable` 对象\n  `thenable` 对象就是有 `then` 方法的对象。\n  `Promise.resolve()` 方法会将 `thenable` 转为 `Promise` 对象，并立即执行其中的 `then` 方法。\n\n```javascript\nconst thenable = {\n  then: function (resolve, reject) {\n    resolve('成功');\n  },\n};\nconst promise = Promise.resolve(thenable);\npromise.then((val) => {\n  console.log(val);\n});\n// 成功\n```\n\n- 参数无 `then` 的对象，或不是对象的参数\n  `Promise.resolve()` 方法返回一个心的 Promise 对象，状态转为 `resolved`。\n\n```javascript\nconst promise = Promise.resolve('成功');\n\npromise.then((val) => {\n  console.log(val);\n});\n// 成功\n```\n\n- 不带参数\n  `Promise.resolve()` 方法可以不传参数，直接返回一个 `resolved` 状态的 `Promise` 对象。\n  所以在希望得到一个 `Promise` 对象，直接调用比较该方法方便。\n\n注意，立即 `resolve()` 的 `Promise` 对象，是在本轮[事件循环（event loop）]()的结束时执行。\n\n```javascript\nconst promise = Promise.resolve();\n\npromise.then(() => {\n  console.log('不带参数');\n});\n// 事件循环\n// 不带参数\nconsole.log('事件循环');\n```\n\n### Promise.reject()\n\n`Promise.reject()` 方法返回一个新 `Promise` 实例，该实例状态为 `rejected`。\n\n```javascript\nconst promise = Promise.reject('出错了的Promise');\n// 同价\nconst promise = new Promise((resolve, reject) => {\n  reject('出错了的Promise');\n});\n\npromise.then(null, (error) => {\n  console.log(error);\n});\n// 出错了的Promise\n```\n","tags":["ES 6"],"categories":["ECMAScript 6"]},{"title":"ES 6 系列之Set 和 Map","url":"/2022/01/18/Blog-ES-6-8-Set-和-Map/","content":"\n## Set\n\n### 介绍\n\n`Set` 是 `ES 6` 提供的新的数据结构。类似于数组，但是都是唯一值，没有重复值。\n`Set` 就是一个构造函数，用来生成 `Set` 数据结构。\n`add()` 就是为 `Set` 添加成员，我们来试试。\n\n```javascript\nconst set = new Set();\nset.add(1);\nset.add(2);\nset.add(3);\nset.add(2);\nset.add(1);\nfor (let s of set) {\n  console.log(s);\n}\n// 1 2 3\n```\n\n代码中可以看出 `Set` 的数据结构，是不会添加重复的值。\n\n`Set` 构造函数可以接受一个数组或者具有 iterable 接口的其他数据结构作为参数，用来初始化 `Set`。\n\n```javascript\nconst arr = [1, 2, 2, 2, 3];\nconst set = new Set(arr);\n\nconsole.log(set);\n// [1, 2, 3]\n```\n\n从这里，我们也可以看出，用于数组去重是一个很好的选择\n\n```javascript\nconst arr = [1, 2, 2, 2, 3, 4];\nconst arr1 = [...new Set(arr)];\nconsole.log(arr1);\n// [1, 2, 3, 4]\n```\n\n### Set 实例属性和方法\n\n**实例属性**\n\n- `Set.prototype.constructor`: 构造函数，默认就是 `Set()`。\n- `Set.prototype.size`: 返回 `Set` 成员总数。\n\n**实例方法**\n\n- `Set.prototype.add(value)`: 添加元素到 `Set`，返回 `Set` 本身。\n- `Set.prototype.delete(value)`: 删除某个值，返回一个布尔值。\n- `Set.prototype.has(value)`: 返回一个布尔值，表示该值是否为 `Set` 的值。\n- `Set.prototype.clear()`: 清除所有值。\n\n```javascript\nconst set = new Set([1, 2, 3, 4]);\n\nset.add(1);\nset.add(5);\nset.add(3);\n\nconsole.log(set.size); // 5\nconsole.log(set.has(5)); // true\nconsole.log(set.has(2)); // true\n\nset.delete(5);\nset.delete(4);\n\nconsole.log(set.has(5)); // false\nconsole.log(set.has(4)); // false\n```\n\n### 遍历操作\n\n四个遍历方法。\n\n- `Set.prototype.keys()`: 返回 `key` 的遍历器\n- `Set.prototype.values()`: 返回 `value` 的遍历器\n- `Set.prototype.entries()`: 返回 `key: values` 的遍历器\n- `Set.prototype.forEach()`: 回调函数遍历，类似数组的 `forEach`\n\n```javascript\nconst set = new Set(['key1', 'key2', 'key3']);\nfor (let key of set.keys()) {\n  console.log(key);\n}\n// key1\n// key2\n// key3\nfor (let val of set.values()) {\n  console.log(val);\n}\n// key1\n// key2\n// key3\nfor (let [k, v] of set.entries()) {\n  console.log(k, v);\n}\n// key1 key1\n// key2 key2\n// key3 key3\n\nset.forEach((val, key) => console.log(key, val));\n// key1 key1\n// key2 key2\n// key3 key3\n```\n\n由遍历，我们可以看出，`key` 与 `value` 的值是相同的。\n\n## Map\n\n### 介绍\n\n`ES 6` 提供了 `Map` 数据结构。类似于对象，也是键值对的集合，但是 `key` 不限制于字符串，其他类型的值均可以作为 `key`。 简单来说 `Map` 结构提供了 `val - val`，而对象必须是 **字符串 - val**。\n\n`map` 的简单用法。也看看将对象作为 `key` 的时候。\n\n```javascript\nconst map = new Map();\nconst obj = {};\nmap.set(obj, 'object');\nconsole.log(map.get(obj)); // 'object'\nmap.set('string', 'hello hzzzzzzzq');\nconsole.log(map.get('string')); // 'hello hzzzzzzzq'\n\nconsole.log(map.has(obj)); // true\nconsole.log(map.has('string')); // true\nconsole.log(map.delete('string')); // true\nconsole.log(map.has('string')); // false\n```\n\n上面我们就可以看出，我们将对象 `obj` 作为一个`Map` 的键传入，使用 `get` 获取值，`delete` 删除，`has` 作为判断是否有这个值。\n\n我们在来看看，`Map` 作为构造函数，怎么添加成员。\n其实在[对象的扩展]()中，我们已经提到过了。\n\n- 接受数组作为参数，而数组的成员是一个个表示键值对的数组。\n\n```javascript\nconst map = new Map([\n  ['x', 1],\n  ['y', 2],\n]);\nconsole.log(map.size); // 2\nconsole.log(map.has('x')); // true\nconsole.log(map.get('x')); // 1\n\nconsole.log(map.has('y')); // true\nconsole.log(map.get('y')); // 2\n```\n\n- 任何具有 `Iterator` 接口，且每个成员都是一个双元素的数组的结构都可以当作 `Map` 的参数。`Set` 和 `Map` 自身也可以作为参数。\n\n```javascript\nconst set = new Set([['x', 1]]);\n\nconst map1 = new Map(set);\nconsole.log(map1.get('x')); // 1\n\nconst map2 = new Map();\nmap2.set('y', 2);\n\nconst map3 = new Map(map2);\nconsole.log(map3.get('y')); // 2\n```\n\n- Map 与 Set 类似，如果有重复 `key` 时，后面的 `val` 会覆盖前面的 `val`，也就是说，`map` 也是唯一的。\n- Map 中若是没有找到这个 `key`，则返回 `undefined`。\n\n```javascript\nconst map = new Map();\nmap.set('x', 1);\nmap.set('x', 2);\nconsole.log(map.get('x')); // 2\nconsole.log(map.get('y')); // undefined\n```\n\n### Map 属性和操作\n\n- size\n  `size` 返回 `Map` 的成员数量。\n\n```javascript\nconst map = new Map();\nmap.set('x', 1);\nconsole.log(map.size); // 1\nmap.set('y', 2);\nconsole.log(map.size); // 2\n```\n\n- Map.prototype.set(key, val)\n  `set(key, val)` 方法就是为 Map 添加新的值了。\n\n```javascript\nconst map = new Map();\n\nmap.set('x', 1); // 键是字符串\nmap.set(1, 2); // 键是数值\nmap.set(undefined, 3); // 键是 undefined\nmap.set(null, 4); // 键时 null\n\nconsole.log(map.get('x')); // 1\nconsole.log(map.get(1)); // 2\nconsole.log(map.get(undefined)); // 3\nconsole.log(map.get(null)); // 4\n```\n\n- Map.prototype.get(key)\n  `get(key)` 方法获取 `key` 对应的 `val`，找不到则返回 undefined。\n\n```javascript\nconst map = new Map();\n\nmap.set('x', 1);\nconsole.log(map.get('x')); // 1\nconsole.log(map.get('y')); // undefined\n```\n\n- Map.prototype.has(key);\n  `has(key)` 方法判断键名 `key` 是否在 `Map` 对象中。\n\n```javascript\nconst map = new Map();\nmap.set('x', 1);\nconsole.log(map.has('x')); // true\nconsole.log(map.has('y')); // false\n```\n\n- Map.prototype.delete(key)\n  `delete(key)` 方法删除某个键，返回一个布尔值，成功为 `true`。\n\n```javascript\nconst map = new Map();\nmap.set('x', 1);\n\nconsole.log(map.delete('x')); // true\nconsole.log(map.delete('y')); // false\n```\n\n- Map.prototype.clear();\n  `clear()` 就是清除 Map 对象的所有成员。\n\n```javascript\nconst map = new Map();\nmap.set('x', 1);\nmap.set('y', 2);\nmap.clear();\n\nconsole.log(map.get('x')); // undefined\nconsole.log(map.get('y')); // undefined\n```\n\n### 遍历\n\n与 `Set` 类似。\n\n- Map.prototype.keys()： 返回 `Map` 对象的所有 `key`。\n- Map.prototype.values()：返回 `Map` 对象的所有 `val`。\n- Map.prototype.entries()：返回 `Map` 对象的所有成员的遍历器。\n- Map.prototype.forEach()：遍历 `Map` 的所有成员。\n\n```javascript\nconst map = new Map();\nmap.set('x', 1);\nmap.set('y', 2);\nmap.set('z', 3);\n\nfor (let key of map.keys()) {\n  console.log(key);\n}\n// 'x'\n// 'y'\n// 'z'\n\nfor (let val of map.values()) {\n  console.log(val);\n}\n// 1\n// 2\n// 3\n\nfor (let [k, v] of map.entries()) {\n  console.log(k, v);\n}\n// 'x' 1\n// 'y' 2\n// 'z' 3\n\nmap.forEach((val, key) => {\n  console.log(key, val);\n});\n// 'x' 1\n// 'y' 2\n// 'z' 3\n```\n","tags":["ES 6"],"categories":["ECMAScript 6"]},{"title":"ES 6 系列之对象的扩展","url":"/2022/01/18/Blog-ES-6-7-对象的扩展/","content":"\n## 属性的简单表示\n\n`ES 6` 允许将属性写在 `{}` 中，直接写入变量和函数，作为对象的属性和方法。这样的书写方式更加简洁。\n\n```javascript\nconst foo = 'foo';\nfunction getName() {\n  console.log('name');\n}\nconst obj = { foo, getName };\n\nconsole.log(obj); // { foo: 'foo', getName: ƒunction }\n\n// ES 6\nconst obj = {\n  foo: 'foo',\n  getName: function () {\n    console.log('name');\n  },\n};\nconsole.log(obj); // { foo: 'foo', getName: function }\n```\n\n## 属性的可枚举性和遍历\n\n### 可枚举性\n\n对象的每个属性都有一个描述对象，用来控制该属性的行为。\n`Object.getOwnPropertyDescriptor` 方法来获取该属性的描述对象。\n\n```javascript\nconst obj = { x: 1 };\nconsole.log(Object.getOwnPropertyDescriptor(obj));\n// {\n//   \"value\": 1,\n//   \"writable\": true,\n//   \"enumerable\": true,\n//   \"configurable\": true\n// }\n```\n\n描述对象的 `enumerable` 属性，称为**可枚举性**，如果该属性为 `false`，就会被某些操作忽略。\n\n操作会忽略 `enumerable` 为 `false` 的属性。\n\n- `for...in` 循环：遍历对象自身和继承的可枚举属性。\n- `Object.keys()`：返回对象所有可枚举的属性的 `key`。\n- `JSON.stringify()`：只串行化对象自身的可枚举的属性。\n- `Object.assign()`：只拷贝对象自身的可枚举属性。\n\n### 属性遍历\n\n- **for...in**\n  `for...in` 循环对象自身的和继续的可枚举属性\n\n```javascript\nconst obj = { x: 1, y: 2, z: 3 };\nfor (let o in obj) {\n  console.log(o);\n}\n// x\n// y\n// z\n```\n\n- **Object.keys(obj)**\n  `Object.keys(obj)` 返回一个数组，包含所有可枚举属性的 `key`。\n\n```javascript\nconst obj = { x: 1, y: 2, z: 3 };\nfor (let o of Object.keys(obj)) {\n  console.log(o);\n}\n// x\n// y\n// z\n```\n\n- **Object.getOwnPropertyNames(obj)**\n  `Object.getOwnPropertyNames(obj)` 返回一个数组，包含对象自身的所有属性的 `key`。\n\n```javascript\nconst obj = { x: 1, y: 2, z: 3 };\nfor (let o of Object.getOwnPropertyNames(obj)) {\n  console.log(o);\n}\n// x\n// y\n// z\n```\n\n- **Object.getOwnPropertySymbols(obj)**\n  `Object.getOwnPropertySymbols(obj)` 返回一个数组，包含对象自身的所有 `Symbol` 属性的 `key`。\n  打印的属性均为 `Symbol`。\n\n```javascript\nconst obj = { [Symbol('x')]: 1, y: 2, z: 3 };\nconsole.log(Object.getOwnPropertySymbols(obj));\n// [Symbol(x)]\n```\n\n- **Reflect.ownKeys(obj)**\n  `Reflect.ownKeys(obj)` 返回一个数组，包含对象自身所有键名，不管键名是 `Symbol` 或字符串，也不管是否可枚举。\n\n```javascript\nconst obj = { [Symbol('x')]: 1, y: 2, z: 3, 1: 10, 2: 11 };\nconsole.log(Reflect.ownKeys(obj));\n// ['1', '2', 'y', 'z', Symbol(x)]\n```\n\n一共五种遍历 `key` 的方式，但是遍历的次序是有规则的。\n\n> - 首先遍历所有数值，并按照升序排列\n> - 其次遍历字符串，按照加入时间升序\n> - 最后才是 `Symbol`，按照加入时间升序\n\n## 对象的扩展运算符\n\n在 [解构赋值](https://github.com/hzzzzzzzq/Blog/issues/4) 和 [数组的扩展](https://github.com/hzzzzzzzq/Blog/issues/7) 中，我们分别提到过对象的解构赋值以及扩展运算符。\n\n我们来看看扩展运算符在对象中的使用。\n\n### 解构赋值\n\n我们来回顾一下 [解构赋值](https://github.com/hzzzzzzzq/Blog/issues/4) 。\n\n```javascript\nconst { x, y } = { x: 1, y: 2 };\nconsole.log(x); // 1\nconsole.log(y); // 2\n```\n\n- 使用扩展运算符时需要注意的是，解构赋值必须是最后一个参数且只能有一个，否则报错。\n\n```javascript\nconst { x, ...obj } = { x: 1, y: 2, z: 3 };\nconsole.log(x); // 1\nconsole.log(obj); // { y: 1, z: 2 }\n\nconst { ...obj, z } = { x: 1, y: 2, z: 3 };\nconsole.log(obj); // 报错\n```\n\n- 对象的解构赋值右侧不能是 `undefined` 或 `null`，会报错\n\n```javascript\nconst { ...obj } = null;\nconst { ...obj } = undefined;\n// TypeError\n```\n\n### 扩展运算符\n\n对象的扩展运算符用于取出参数对象的所有可便利属性，拷贝到当前对象之中。\n\n```javascript\nconst obj = { x: 1, y: 2 };\nconst obj2 = { ...obj };\nconsole.log(obj); // { x: 1, y: 2 }\n```\n\n- 数组也是特殊的对象，所以对象的扩展运算符也可以用于数组。\n\n```javascript\nconst obj = { ...['1', '2', '3'] };\nconsole.log(obj);\n// { 0: '1', 1: '2', 2: '3' }\n```\n\n- 如果是空对象，则没有任何效果。\n\n```javascript\nconst obj = { ...{}, x: 1 };\nconsole.log(obj); // { x: 1 }\n```\n\n- 如果扩展运算符并不是对象，则会被自动转化成对象，但是部分值没有自身属性，所以会返回一个空对象 `{}`。\n\n```javascript\nconst obj = { ...1 }; // 等同于 { ...Object(1) }\nconst obj2 = { ...true }; // { ...Object(true) }\nconst obj3 = { ...undefined }; // { ...Object(undefined) }\nconst obj4 = { ...null }; // { ...Object(null) }\n```\n\n- 如果后面跟着字符串，则会自动转成类数组对象\n\n```javascript\nconst obj = { ...'hzq' };\nconsole.log(obj); // { 0: 'h', 1: 'z', 2: 'q' }\n```\n\n## 对象新增的常用实例方法\n\n## Object.is()\n\n`Object.is()` 是用来判断两个是否严格相等，与严格比较运算符 `===` 行为基本一致。\n\n```javascript\nconsole.log(Object.is('hello', 'world')); // false\nconsole.log(Object.is('hello', 'hello')); // true\nconsole.log(Object.is({}, {})); // false\n```\n\n#### 与 `===` 不同点\n\n```javascript\nconsole.log(+0 === -0); // true\nconsole.log(NaN === NaN); // false\n\nconsole.log(Object.is(+0, -0)); // false\nconsole.log(Object.is(NaN, NaN)); // true\n```\n\n## Object.assign()\n\n`Object.assign()` 放啊主要用于对象的合并，**将对象的所有可枚举属性复制到目标对象**。\n\n```javascript\nconst obj = {};\nconst obj1 = { x: 1 };\nconst obj2 = { y: 2 };\nObject.assign(obj, obj1, obj2);\nconsole.log(obj);\n// { x: 1, y: 2 }\n```\n\n从上面我们可以看出，第一个参数就是**目标对象**，将后面对象的所有**可枚举属性**复制到第一个参数。\n\n- 如果后面参数中，有同名属性，则目标对象中的值，会被新的对象替代\n- 如果只有一个参数，则直接返回该参数\n\n```javascript\nconst obj = { x: 1 };\nconst obj1 = { x: 3, y: 2 };\nconst obj2 = { y: 4 };\nObject.assign(obj, obj1, obj2);\nconsole.log(obj);\n// { x: 3, y: 4 }\n\nconst obj3 = { x: 3 };\nconsole.log(Object.assign(obj3) === obj3);\n// true\n```\n\n- 如果参数不是对象，会被转成对象，然后返回\n- `undefined` 和 `null` 无法转成对象，会报错\n\n```javascript\nconsole.log(Object.assign(1));\n// Number {1}\nconsole.log(typeof Object.assign(1));\n// object\nconsole.log(Object.assign(undefined)); // 报错\nconsole.log(Object.assign(null)); // 报错\n```\n\n## Object.keys()，Object.values()，Object.entries()\n\n### Object.keys()\n\n`Obejct.keys()` 是 `ES 5` 引入的，我们还是在这里稍微提一下。**Object.keys()返回对象键值的数组，然后用来遍历对象的 key。**\n\n```javascript\nconst obj = { x: 1, y: 2, z: 3 };\nfor (let key of Object.keys(obj)) {\n  console.log(key);\n}\n// x\n// y\n// z\n```\n\n### Object.values()\n\n`Object.values()` 是 `ES 6` 时引入的，返回一个数组，是每个键对应的值。返回值的顺序可以参照，对象的可枚举性中顺序。\n\n当然许多特性是类似的。\n\n- 返回的是可遍历的值，`enumerable` 为 `true`\n- 如果转化的值不是对象，则会先转化为对象。\n  - 字符串会被转为数组输出，\n  - 布尔值、数值都不会为实例添加非继承的属性，返回空数组\n  - `Symbol` 作为 `key` 会被忽略\n\n```javascript\nconst objVal = { 1: 'a', 2: 'b', 7: 'c' };\nconsole.log(Object.values(objVal));\n// [\"b\", \"c\", \"a\"]\nconst obj = { [Symbol()]: 1, x: 2, y: 3 };\nconsole.log(Object.values(obj));\n// [2, 3];\nconst str = 'hello';\nconsole.log(Object.values(str));\n// ['h', 'e', 'l', 'l', 'o'];\nconsole.log(Object.values(true));\n// []\nconsole.log(Object.values(11));\n// []\n```\n\n### Object.entries()\n\n`Object.entries()` 方法返回一个数组，成员是参数对象自身的所有可遍历属性的键值对数组。\n\n```javascript\nconst obj = { x: 1, y: 2, z: 3 };\nconsole.log(Object.entries(obj));\n// [[\"x\", 1], [\"y\", 2], [\"z\", 3]]\n```\n\n- 对象的属性名是一个 `Symbol` 值，该属性会被忽略。\n\n```javascript\nconst obj = { [Symbol()]: 1, x: 2 };\nconsole.log(Object.entries(obj));\n// [['x', 2]]\n```\n\n#### 两个用途\n\n- 遍历对象的属性\n\n```javascript\nconst obj = { x: 1, y: 2 };\nfor (let [k, v] of Object.entries(obj)) {\n  console.log(`key = ${k}, val = ${v}`);\n}\n// key = x, val = 1\n// key = y, val = 2\n```\n\n- 将对象转为真正的 [Map 结构]()\n\n```javascript\nconst obj = { x: 1, y: 2 };\nconst map = new Map(Object.entries(obj));\nconsole.log(map);\n// Map { x: 1, y: 2 }\n```\n\n## Object.fromEntries()\n\n`Object.fromEntries()` 是 `Object.entries()` 的逆向操作，**用于将一个键值对数组转为对象**。\n\n```javascript\nconst arr = [\n  ['x', 1],\n  ['y', 2],\n  ['z', 3],\n];\nconsole.log(Object.fromEntries(arr));\n// { x: 1, y: 2, z: 3 }\n```\n\n### 用途\n\n主要作用就是，是将键值对的数据结构还原为对象\n\n- 将 [`Map` 结构](https://github.com/hzzzzzzzq/Blog/issues/9)转为对象\n\n```javascript\nlet map = new Map();\nmap.set('x', 1);\nmap.set('y', 2);\nmap.set('z', 3);\nconsole.log(Object.fromEntries(map));\n// { x: 1, y: 2, z: 3 }\n```\n\n对象的扩展，我们就先介绍到这里，如果有问题，会对文章进行更新。\n\n**感谢各位的观看!**\n","tags":["ES 6"],"categories":["ECMAScript 6"]},{"title":"ES 6 系列之数组的扩展","url":"/2022/01/18/Blog-ES-6-6-数组的扩展/","content":"\n## 扩展运算符\n\n基本使用，扩展运算符是什么，其实就是三个点( `...` )，在[2. 变量的解构赋值 - 数组](https://github.com/hzzzzzzzq/Blog/issues/4) 和 [4. 函数的扩展 - rest 参数](https://github.com/hzzzzzzzq/Blog/issues/6)中，接触过。\n\n其实就是讲一个数组转为用逗号分隔的参数序列。\n\n```javascript\nlet arr = [1, 2, 3, 4, 5];\nconsole.log(...arr); // 1 2 3 4 5\n\nlet str = 'Hello';\nconsole.log(...str); // H e l l o\n```\n\n从上面的代码中，我们能够看出，其实扩展运算符就是拆解数组、字符串等类似结构。\n\n当然，在这里需要注意的是只能拆一层的内容，**如果数组中有对象，或者嵌套了一个数组是不可拆的**。\n\n```javascript\nlet arr = [1, 2, { a: 1 }, 4];\nconsole.log(...arr); // 1 2 { a: 1 } 4\n```\n\n在**对象中使用大多用来拷贝一个对象，并进行部分修改**。\n\n```javascript\nlet obj = {\n  a: 1,\n  b: 2,\n  c: {\n    x: 3,\n  },\n};\n// 下面的 a: 4,就是对a的值进行修改。\nlet obj2 = { ...obj, a: 4 };\nconsole.log(obj2);\n// a: 4\n// b: 2\n// c: { x: 3 }\n```\n\n## 数组新增的方法\n\n### Array.form()\n\n该方法用于将**类似数组的对象**和**可遍历的对象**转为真正的数组\n\n```javascript\nlet arrayLike = {\n  0: 'x',\n  1: 'y',\n  2: 'z',\n  length: 3,\n};\nlet arr = Array.from(arrayLike);\nconsole.log(arr); // ['x', 'y', 'z']\n```\n\n### Array.of()\n\n该方法用于**将一组值转化成数组**\n\n```javascript\nlet arr = Array.of(1, 2, 3, 4);\nconsole.log(arr); // [1, 2, 3, 4]\n```\n\n### 新增的实例方法\n\n#### find() 和 findIndex()\n\n- **find()**\n\n`find()` 方法，简单来说就是**在数组中找出想要的那个值**。\n\n可以传入三个参数，第一个参数表示，当前值；第二个参数表示，当前值所在数组中的位置；第三个参数表示，原数组。当然，`find()` 顾名思义，就是查询，会找出第一个返回 `true` 的成员。\n\n```javascript\nlet arr = [1, 3, 5, 7, 9];\nconst value = arr.find((val) => {\n  return val > 7;\n});\nconsole.log(value); // 9\n\n// 来看看有两个相同值时，返回的是哪个值？\nconst value2 = arr.find((val) => {\n  return val > 6;\n});\nconsole.log(value2); // 7\n```\n\n`find()` 方法中，可以传递第二个参数，用来绑定 `this`\n\n```javascript\nlet age = {\n  first: 10,\n  second: 20,\n};\nlet ages = [11, 20, 22];\nconst value = ages.find(function (val) {\n  return val > this.first;\n}, age);\nconsole.log(value); // 11\n```\n\n在上面通过参数二传入一个对象，来绑定 `this`。当然这里可以会有疑问，为什么不用箭头函数了？ 这里具体可以去看看 [普通函数与箭头函数的 `this` 指向问题]()。\n\n- **findIndex()**\n\n`findIndex()` 方法与 `find()` 方法非常接近，**返回第一个符合条件的成员的位置(也就是数组的下标)，如果找不到，则返回 `-1`**。\n\n```javascript\nlet arr = [1, 3, 5, 7, 9];\nconst index = arr.findIndex((value) => {\n  return value > 7;\n});\nconsole.log(index); // 4\n\n// 来看看两个符合条件值时，返回是第几个的位置？\nconst index2 = arr.findIndex((value) => {\n  return value > 6;\n});\nconsole.log(index2); // 3\n```\n\n`findIndex()` 方法是可以通过 `Objecy.is(NaN)` 来识别出 `NaN` 的。\n\n```javascript\nconsole.log([NaN].findIndex((val) => Object.is(NaN, val)));\n// 0\n```\n\n#### fill()\n\n`fill` 方法使用给定值，**填充一个数组**。\n\n参数可传一共三个\n\n- 第一个参数 - 被填充的值。\n- 第二个、第三个参数 - 用于填充的起始位置和结束位置\n\n后两个参数可以不传，视为所有元素都是被填充元素。\n\n```javascript\nlet arr = [1, 2, 3];\nconsole.log(arr.fill(3)); // [3, 3, 3]\n\nlet array = [1, 2, 3];\nconsole.log(arr.fill(5, 1, 2)); // [1, 5, 3]\n```\n\n#### keys()、values() 和 entries()\n\nES6 提供的新的方法 **用来遍历数组** 。返回的都是一个**遍历器对象**，可以用 `for...of` 循环进行遍历。\n\n- **keys()**\n\n`keys()` 实例方法，就是为了**遍历数组的 key**。\n\n```javascript\nlet arr = ['x', 'y', 'z'];\nfor (let key of arr.keys()) {\n  console.log(key);\n}\n// 0\n// 1\n// 2\n```\n\n- **values()**\n\n`values()` 实例方法，是为了**遍历数组的值**。\n\n```javascript\nlet arr = ['x', 'y', 'z'];\nfor (let val of arr.values()) {\n  console.log(val);\n}\n// 'x'\n// 'y'\n// 'z'\n\n// 相当于普通的循环遍历\nfor (let i = 0; i < arr.length; i++) {\n  console.log(arr[i]);\n}\n// 'x'\n// 'y'\n// 'z'\n```\n\n- **entries()**\n\n`entries()` 实例方法，**是对键值对的遍历**。 在这里还用到了[数组的解构赋值](https://github.com/hzzzzzzzq/Blog/issues/4)。\n\n```javascript\nlet arr = ['x', 'y', 'z'];\nfor (let [key, value] of arr.entries()) {\n  console.log(key, value);\n}\n// 0 'x'\n// 1 'y'\n// 2 'z'\n```\n\n上面代码中的 `[key, value]`，其实就是遍历 `arr.entries()` ，并对其中一个值进行[解构赋值](https://github.com/hzzzzzzzq/Blog/issues/4)。\n\n可以来看看不使用 `for...of` 的写法，需要自己**手动调用遍历器对象的 `next` 方法，然后`.value` 去取到相应值**，为了方便这里就写在一起了\n\n```javascript\nlet arr = ['x', 'y', 'z'];\n// keys()\nlet keys = arr.keys();\nconsole.log(keys.next().value); // 0\nconsole.log(keys.next().value); // 1\nconsole.log(keys.next().value); // 2\n// values()\nlet values = arr.values();\nconsole.log(values.next().value); // 'x'\nconsole.log(values.next().value); // 'y'\nconsole.log(values.next().value); // 'z'\n// entries()\nlet entries = arr.entries();\nconsole.log(entries.next().value); // [0, 'x']\nconsole.log(entries.next().value); // [1, 'y']\nconsole.log(entries.next().value); // [2, 'z']\n```\n\n#### includes()\n\n`includes()` 实例方法，就是用来做一个判断，表示**某个数组是否包含给定过的值**，与字符串的 `includes` 方法类似。\n\n```javascript\nlet arr = ['x', 'y', 'z', undefined, NaN];\nconsole.log(arr.includes('x')); // true\nconsole.log(arr.includes('1')); // false\nconsole.log(arr.includes(undefined)); //true\nconsole.log(arr.includes(NaN)); // true\n```\n\n`includes()` 方法的第二个参数表示**搜索的起始位置**\n\n```javascript\nlet arr = ['x', 'y', 'z', undefined, NaN];\nconsole.log(arr.includes('x', 1)); // false\n```\n\n上面的例子表示，检索数组从下标 `1` 开始检索，所以第一个参数 `'x'`，就检索不到啦。\n\n#### flat(),flatMap()\n\n- **flat()**\n\n`flat()` 就是简单来说就是 **数组的扁平化**，如果数组内嵌套数组，那就可以将其转为单层数组。\n\n```javascript\nlet arr = [1, 2, 3, [4]];\nconsole.log(arr.flat()); // [1, 2, 3, 4]\n```\n\n当然，默认情况下，只会偏平一层，如果传入参数就可以偏平自己需要的层数。\n\n```javascript\nlet arr = [1, 2, [3, [4, [5]]]];\nconsole.log(arr.flat()); // [1, 2, 3, [4, [5]]]\nconsole.log(arr.flat(2)); // [1, 2, 3, 4, [5]]\nconsole.log(arr.flat(3)); // [1, 2, 3, 4, 5]\n```\n\n**注意**\n\n如果你需要无论多少层都将其转化为一层，使用`正无穷(Infinity)`作为参数即可。\n\n如果数组有**空位**，`flat()` 函数则会将空位跳过\n\n```javascript\nlet arr = [1, [2, [3, [4, [5, [6]]]]]];\nconsole.log(arr.flat(Infinity)); // [1, 2, 3, 4, 5, 6]\n\nlet array = [1, , 3, , 5];\nconsole.log(array.flat()); // [1, 3, 5]\n```\n\n- **flatMap()**\n\n`flatMap()` 实例方法，可以理解为，对数组进行 `map` 操作，然后对返回值组成的数组执行 `flat()` 方法。该实例方法，返回一个新的数组，不会改变原数组。\n\n```javascript\nlet arr = [1, 2, 3, [4]];\nlet array = arr.flatMap((item) => item * 2);\nconsole.log(array); // [2, 4, 6, 8]\n```\n\n**注意**\n\n该方法只能展开一层，无法多层展开，有兴趣的，可以去验证一下。\n","tags":["ES 6"],"categories":["ECMAScript 6"]},{"title":"ES 6 系列之函数的扩展","url":"/2022/01/18/Blog-ES-6-5-函数的扩展/","content":"\n## 函数参数默认值\n\n### 基本用法\n\n我们来介绍一下函数的默认值，在 ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方式。\n\n我们先来看看 ES6 之前怎么给函数参数添加默认值\n\n```javascript\nfunction add(x, y) {\n  y = y || 1;\n  return x + y;\n}\nconsole.log(add(1)); // 2\nconsole.log(add(1, 2)); // 3\n```\n\n我们做的是检查 `y` 的值有没有传入，如果没有则会默认被赋值为 `1`。这种方式是有缺点的，如果传入的值为**布尔值 `false`**，那么传入的值会变得无效。**空字符串**也是会有布尔值 `false` 一样的结果。\n\n那么现在我们来看看 ES6 允许设置默认值的写法吧\n\n```javascript\nfunction add(x = 1, y = 2) {\n  return x + y;\n}\nconsole.log(add()); // 3\nconsole.log(add(3)); // 5\nconsole.log(add(2, 3)); // 5\n```\n\n从上面的代码就可以看到，一眼就可以**判断出参数是否可省略，且写法比 `ES5` 简洁许多**\n\n> 注意：\n>\n> - 函数的参数变量是默认声明的，所以不能使用 let 或者 const 再次声明。\n> - 参数默认值的位置，必须是在函数的尾部，如果不是在尾部，否则是没法省略的。\n\n### **解构赋值与默认值结合使用**\n\n```javascript\nfunction add([x, y] = [1, 2]) {\n  return x + y;\n}\n```\n\n来我们还是先用 `add` 函数来举例，上面就是用的数组的解构赋值，可以个传入的数组进行解构赋值，默认解构赋值。\n\n### 函数的 length\n\n很奇怪吧，函数居然能有 `length`，来我们在这里简单提一下函数的 `length` 是什么。\n\n```javascript\nconsole.log(function (x) {}.length); // 1\nconsole.log(function (x = 1) {}.length); // 0\nconsole.log(function (x, y, z = 2) {}.length); // 2\n```\n\n没错，就是这样。它的 `length` 就是函数必须传入的参数，也就是函数的所有参数减去制定了默认值的参数个数。 如果设置了默认值的参数不是尾参数，那么 `length` 属性也不再计入后面的参数了。\n\n### 作用域\n\n---\n\n## rest 参数\n\nES6 中引入来 `rest` 参数（形式为 `...变量名` ），用于获取函数的多余参数，替代 `arguments` 对象。\n\n我们还是那 `add` 函数来举例吧。\n\n```javascript\nfunction add(...values) {\n  let sum = 0;\n  for (let num of values) {\n    sum += num;\n  }\n  return sum;\n}\nconsole.log(add(1, 2, 3, 4, 5)); // 15\n```\n\n这里就可以看出来，`rest` 参数是做什么用的，使用它之后，参数可以无限传入，不限制定量。\n\n函数的 `length` 不包括 `rest` 参数。\n\n---\n\n## 箭头函数\n\n### 基本使用\n\n我们来看看 ES6 中增加的箭头函数( `=>` )，来我们还是用 `add` 函数来举例子，\n\n```javascript\nfunction add(a, b) {\n  return a + b;\n}\n\n// 等价于\nconst add = (a, b) => {\n  return a + b;\n};\n```\n\n来看看更简单的写法\n\n```javascript\nfunction multiply(n) {\n  return n * n;\n}\n// 等价于\nconst multiply = (n) => n * n;\n```\n\n有时候 `return` 可以省略。\n\n当然，箭头函数可以**嵌套**使用，会大大增加代码量\n\n```javascript\nfunction add(x) {\n  return function (y) {\n    return function (z) {\n      return x + y + z;\n    };\n  };\n}\n```\n\n上面是普通的写法，然后我们来看一下箭头函数的写法\n\n```javascript\nconst add = (x) => (y) => (z) => x + y + z;\n```\n\n对比一下，应该就知道啦，两种的写法简便程度差别真的很大。\n\n### 注意点\n\n在这里，稍微提一下箭头函数的相关注意点：\n\n- 箭头函数没有自己的 `this` 对象\n- 不可以当作构造函数，即不可使用 `new` 命令\n- 不可以使用 `arguments` 对象，不存在该对象，但是可以使用 `rest` 参数代替\n- 不可以使用 `yield` 命令，因此箭头函数不能使用 `Generator` 函数\n\n在这里不特点讲述，如果想要具体了解，可以看一下我的另一篇文章[Javasctip - this 指向]()，文章后续补齐。\n","tags":["ES 6"],"categories":["ECMAScript 6"]},{"title":"ES 6 系列之字符串的扩展","url":"/2022/01/18/Blog-ES-6-4-字符串的扩展/","content":"\n## 字符串的遍历\n\nES6 中添加了字符串的遍历器接口，字符串就可以使用 `for...of` 来遍历了。\n\n```javascript\nlet s = 'Hello';\nfor (let c of s) {\n  console.log(c); // H e l l o\n}\n```\n\n## `JSON.stringify()` 和 `JSON.parse()`\n\n在有时候，我们需要将一个 `JSON` 格式的数据，转成字符串进行页面传递。\n所以这时候采用 `JSON.stringify()` 进行序列化。然后传递，在目的页面使用 `JSON.parse()` 转为 `JavaScript` 对象。在进行大数据传递时，时常需要。\n\n```javascript\nlet person = {\n  name: 'hzzzzzzzq',\n  age: 18,\n  height: 1.8,\n  weight: 140,\n  skills: ['JavaScript'],\n};\nlet s = JSON.stringify(person);\nconsole.log(s);\n// {\"name\":\"hzzzzzzzq\",\"age\":18,\"height\":1.8,\"weight\":140,\"skills\":[\"JavaScript\"]}\n\nlet str = JSON.parse(s);\nconsole.log(str);\n// {\n//  \"name\": \"hzzzzzzzq\",\n//  \"age\": 18,\n//  \"height\": 1.8,\n//  \"weight\": 140,\n//  \"skills\": [\n//     \"JavaScript\"\n//   ]\n// }\n```\n\n## 模版字符串\n\n什么是模版字符串呢？简单来说，其实就是加强版的字符串，使用 ( **`** )作为标识符 。可以作为普通的字符串使用，也可以用来定义多行字符串，或者在字符串中使用变量。\n\n我们来看看使用普通字符串时 是怎么进行换行，或者加入变量的。\n\n```javascript\nlet name = 'hzzzzzzzq';\nlet age = 18;\nlet info = 'my name is ' + name + '\\n my age is ' + age;\nconsole.log(info);\n// my name is hzzzzzzzq\n// my age is 18\n```\n\n然后我们再来看看模版字符串的写法。\n\n```javascript\nlet name = 'hzzzzzzzq';\nlet age = 18;\nlet info = `my name is ${name}\nmy age is ${age}`;\nconsole.log(info);\n// my name is hzzzzzzzq\n// my age is 18\n```\n\n换行，直接就使用回车就可以换行，你输入的样子是怎样的，打印基本上就是怎样的。\n\n变量采用 `${}` 来嵌入，也可以直接写入一个字符串中，少写了许多没必要的 `+` 号。\n\n## 字符串中的新增方法\n\n在这里就列举一些常用的实例方法\n\n### includes()\n\n`includes()` 实例方法，返回的是一个布尔值（`true`和`false`），**表示是否找到了参数字符串**。\n参数二来表示开始搜索的位置。\n\n```javascript\nlet s = 'Hello hzzzzzzzq';\nconsole.log(s.includes('Hello')); // true\nconsole.log(s.includes('x')); // false\nconsole.log(s.includes('zzzzzzz')); // true\nconsole.log(s.includes('H', 2)); // false\n```\n\n### startsWith()、endsWith()\n\n- **startsWith()**\n  `startsWith()` 返回也是布尔值，**表示参数是否在原字符串的头部**。\n  第二参数也表示开始搜索的位置。\n\n```javascript\nlet s = 'Hello hzzzzzzzq';\nconsole.log(s.startsWith('Hello')); // true\nconsole.log(s.startsWith('e')); // false\n// 表示从 1 开始\nconsole.log(s.startsWith('Hello', 1)); // false\n```\n\n- **endsWith()**\n  `endsWith()` 返回也是布尔值，**表示参数是否在原字符串的尾部**。\n  注意：这里的第二参数表示的是到 n 为止，不像 `startsWith()` 是从 `n` 开始到字符串结尾。\n\n```javascript\nlet s = 'Hello hzzzzzzzq';\nconsole.log(s.endsWith('q')); // true\nconsole.log(s.endsWith('zzzzq')); // true\n// 表示看前 5 个字符\nconsole.log(s.endsWith('o', 5)); // true\n// 表示看前 4 个字符\nconsole.log(s.endsWith('o', 4)); // false\n```\n\n### repeat()\n\n`repeat()` 返回一个新字符串，表示将原字符串重复 `n` 次。\n\n- 如果传入的是小数，则会往下取整。\n- 传入参数不能是 `Infinity` 和 小于 `-1` 的值\n- `0` 到 `-1` 之间的小数，则按照等同于 `0` 来计算。\n- `NaN` 会被转为 `0`\n- 参数是字符串则先转为数字，如果不能转为数字，则为 `0`\n\n```javascript\nlet s = 'a';\nconsole.log(s.repeat(4)); // 'aaaa'\nconsole.log(s.repeat(3.6)); // 'aaa'\nconsole.log(s.repeat(-0.6)); // ''\nconsole.log(s.repeat('aaa')); // ''\n```\n\n### padStart、padEnd()\n\n两个实例方法，就是用于字符串的补齐。\n**第一参数表示想要字符串的长度，第二参数表示字符串没达到第一参数时使用参数二字符串进行补齐。**\n\n- **padStart()**\n  很明显，`Start`，就是在字符串的头部补全。\n\n```javascript\nlet s = 'aaa';\n// 如果原长度大于或等于想要补齐长度，则不生效。\nconsole.log(s.padStart(2, 'b')); // aaa\nconsole.log(s.padStart(10, 'b')); // bbbbbbbaaa\n// 如果补齐字符串长度大于剩余格数，则会省略后面字符串\nconsole.log(s.padStart(4, 'bcde')); // baaa\n// 如果，第二参数无内容，则使用空格补齐\nconsole.log(s.padStart(4)); // ' aaa'\n```\n\n- **padEnd()**\n  `End` 就是在字符串的尾部补全。\n\n```javascript\nlet s = 'aaa';\n// 如果原长度大于或等于想要补齐长度，则不生效。\nconsole.log(s.padEnd(2, 'b')); // aaa\nconsole.log(s.padEnd(10, 'b')); // aaabbbbbbb\n// 如果补齐字符串长度大于剩余格数，则会省略后面字符串\nconsole.log(s.padEnd(4, 'bcde')); // aaab\n// 如果，第二参数无内容，则使用空格补齐\nconsole.log(s.padEnd(4)); // 'aaa '\n```\n\n### trimStart()、trimEnd()\n\n这两个实例都是用来**去除字符串空格用的**。\n\n```javascript\nlet s = '   x   ';\n// start 去除前面空格\nconsole.log(s.trimStart()); // 'x   '\n// end 去除后面空格\nconsole.log(s.trimEnd()); // '   x'\n```\n\n### replaceAll()\n\n`replaceAll()` 实例方法是用来替换字符串中的字符用的。\n\n在提到这个之前，我们先看看 `replace()` ，**参数一是被替换的值，参数二是替换值**，简单来讲就是，**参数二用来替换参数一**。\n\n```javascript\nlet s = 'abcabc';\nconsole.log(s.replace('a', 'x')); // xbcabc\n```\n\n`replace()` 只能替代一个，是第一个遇到的。\n\n那我们来看看 `replaceAll()`，是全部替换。\n\n```javascript\nlet s = 'abcabc';\nconsole.log(s.replaceAll('a', 'x')); // xbcxbc\n```\n\n这里是简单的用法，当然在 `replaceAll()` 第二参数还可以传入一个函数，具体可以看看 [MDN 的 replaceAll()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll)\n","tags":["ES 6"],"categories":["ECMAScript 6"]},{"title":"ES 6 系列之变量的解构赋值","url":"/2022/01/18/Blog-ES-6-3-变量的解构赋值/","content":"\n解构赋值：ES6 允许按照一定模式，从数组、字符串和对象中提取值，对变量进行赋值\n\n我们来看一下以前赋值的方式\n\n```javascript\nlet a = 1;\nlet b = 2;\n```\n\n那么现在我们来初步了解一下解构赋值\n\n```javascript\nlet [a, b] = [1, 2];\n```\n\n上面两段代码的赋值结果是相同的。\n\n---\n\n## 数组的解构赋值\n\n### 基本使用\n\n我们来看看数组的解构赋值，在上面中，我们使用了数组的解构赋值，来举例子。\n\n```javascript\nlet [a, b, c, d] = [1, 2, 3, 4];\n```\n\n这样操作之后，就可以从数组中提取到相应的值，**按照对应位置，对变量赋值**。\n\n本质上，也就是模式的匹配，只要等号两边的模式相同，左边的变量就会被赋予对应的值。\n\n我们来多举例\n\n```javascript\n// 例子1\nlet [a, [b], [c]] = [1, [2], [3]];\nconsole.log(a); // 1\nconsole.log(b); // 2\nconsole.log(c); // 3\n```\n\n从 `例子1` 中可以看出，这是一种嵌套数组取值方式，可以看出，数组的解构赋值，可以进行嵌套取值。\n\n```javascript\n// 例子2\nlet [, a] = [1, 2];\nconsole.log(a); // 2\n```\n\n从 `例子2` 来看，就证明了数组赋值解构说的这句话，**按照对应的值，对变量进行赋值**，而不是每次都从第一个开始取。\n\n```javascript\n// 例子3\nlet [a, ...arr] = [1, 2, 3, 4];\nconsole.log(a); // 1\nconsole.log(arr); // [2, 3, 4];\n```\n\n从 `例子3` 来看，我们也可以用 [扩展运算符](https://github.com/hzzzzzzzq/Blog/issues/7) 这里需要一个扩展运算符的项目，来同时将后面的值放到一个数组中。\n\n```javascript\n// 例子4\nlet [a, b, ...arr] = [1];\nconsole.log(a); // 1\nconsole.log(b); // undefined\nconsole.log(arr); // []\n```\n\n从 `例子4` 来看，我们能发现，如果在右侧找不到值时，就是解构不成功，这时候如果是单变量，则会等于 [`undefined`](数据基本结构)，如果是使用了 [扩展运算符](https://github.com/hzzzzzzzq/Blog/issues/7) 的变量，则是空数组。\n\n### 默认值\n\n接下来，我们来看一下解构赋值中指定默认值\n\n```javascript\n// 例子5\nlet [a = 10] = [];\nconsole.log(a); // 10\n```\n\n在上面的 `例子5` 中，可以看到，`a` 对应的右侧是解构失败的，值应该为 `undefined`，但是输出是 `10`，这就是因为**解构赋值中允许指定默认值**\n\n但是默认值是有生效条件的：**只有当一个数组成员严格等于 `undefined` 时，默认值才会生效**。\n\n> ES6 中的严格相等运算符( `===` )，可以判断一个位置是否有值。\n\n```javascript\n// 例子6\nlet [a = 1, b = 2, c = 3] = [10, null, undefined];\nconsole.log(a); // 10\nconsole.log(b); // null\nconsole.log(c); // 3\n```\n\n在 `例子6` 中，就可以看出只有当右侧的值严格相等于 `undefined` 时，默认值才会生效。\n\n---\n\n## 对象的解构赋值\n\n解构赋值并不只是在数组中，在对象中也可以。\n\n### 基本使用\n\n```javascript\n// 例子7\nlet { a, b } = { a: 'aaa', b: 'bbb' };\nconsole.log(a); // 'aaa'\nconsole.log(b); // 'bbb'\n```\n\n从 `例子7` 中，我们可以看出对象的解构赋值与数组的解构赋值的一个重要的不同点。数组元素是按照对应的下标次序来排列的，但是在对象中，变量必须与属性同名，才可以取到正确的值\n\n```javascript\n// 例子8\nlet { b, c } = { a: 'aaa', b: 'bbb' };\nconsole.log(b); // 'bbb'\nconsole.log(c); // undefined\n```\n\n从 `例子8` 中，我们可以看到，对象的解构赋值，变量必须与属性同名，且并不是按照次序来对应的。同数组，解构失败时，变量的值等于 `undefined`。\n\n```javascript\n// 例子9\nlet {\n  a: { b },\n} = { a: { b: 20 } };\nconsole.log(b); // 20\n\n// 例子10\nlet { a } = { a: { b: 20 } };\n```\n\n从 `例子9` 中，我们可以看到，对象的解构赋值，也是同数组一样，可以进行嵌套取值。\n\n> 注意：在这里 `例子9` 中左侧的 `a` 是模式，不是变量，因此不会被赋值，如果想要 `a` 也被赋值，可以使用 `例子10` 的写法\n\n### 默认值\n\n我们在数组解构赋值中，可以使用默认值，那么在对象中，是不是也有呢？\n\n```javascript\n// 例子11\nlet { a = 1 } = {};\nconsole.log(a); // 1\n\n// 例子12\nlet { a, b = 2 } = { a: 1 };\nconsole.log(a); // 1\nconsole.log(b); // 2\n\n// 例子13\nlet { a: b = 1 } = {};\nconsole.log(b); // 1\n```\n\n从 `例子11`、`例子12`、`例子13`，可以看出，其实对象的默认值与数组的默认值是类似的。\n\n---\n\n## 字符串的解构赋值\n\n字符串也是可以进行解构赋值的，其实就是相当于将字符串转化成一个类似数组的对象。\n\n```javascript\n// 例子14\nlet [a, b, c, d, e] = 'hello';\nconsole.log(a); // 'h'\nconsole.log(b); // 'e'\nconsole.log(c); // 'l'\nconsole.log(d); // 'l'\nconsole.log(e); // 'o'\n```\n\n从 `例子14` 来看，就可以明白了，数组的解构赋值相当于被转化成一个类数组的对象进行解构赋值。\n\n---\n\n## 函数参数的解构赋值\n\n函数的参数也是可以使用解构赋值\n\n```javascript\n// 例子15\nfunction add([a, b]) {\n  return a + b;\n}\nconsole.log(add([1, 2])); // 3\n```\n\n从 `例子15` 可以看出，函数的参数是可以进行解构赋值的，既然**数组**可以，那么**对象**也可以，**字符串**也是。\n\n---\n","tags":["ES 6"],"categories":["ECMAScript 6"]},{"title":"ES 6 系列之Let 和 const 命令","url":"/2022/01/18/Blog-ES-6-2-let-和-const-命令/","content":"\n## let 命令\n\n### **简单实用**\n\nES6 中新增了 `let` 命令，用来声明变量。使用方式同 `var` 命令，但是 `let` 命令只在所在的代码块内有效。\n\n```javascript\n{\n  let a = 10;\n  var b = 10;\n}\nconsole.log(a); // 报错，a 为定义 ReferenceError: a is not defined\nconsole.log(b); // 10\n```\n\n在上面的使用案例中，我们可以看出 `let` 命令只在代码块中生效，而在代码块以外使用则无效。\n\n### **for 循环中使用**\n\n我们来看看在 `for` 循环中使用 `var` 命令.\n\n下面这段代码，打印出来的会是什么呢？可以跑一下代码，看一下控制台。\n\n```javascript\nfor (var i = 0; i < 5; i++) {\n  console.log(i);\n}\nconsole.log(i); // 5\n```\n\n好了，你会发现，所有的打印都是 `5`，为什么呢？是因为 `var` 命令是在全局范围内有效，所以全局只有一个变量 `i`，每一次循环，变量 `i` 的值都会发生改变，所以当你打印是，打印的就是全局的 `i` ，也就是经过多次变化赋值的 `5`。\n\n上面代码中，我在外面打印了一下 `i` ，来证明 `var` 定义的是一个全局变量。\n\n来，让我们将 `var` 改成 `let`，现在打印的结果又是什么呢？\n\n```javascript\nfor (let i = 0; i < 5; i++) {\n  console.log(i);\n}\nconsole.log(i); // ReferenceError: i is not defined\n```\n\n当然，我想很多人都猜到了结果，就是 `0 1 2 3 4` ，那么这里又是为什么呢？\n\n`let` 变量只在所在的代码块内有效，在子代码块中依然有效。在上述循环中 `i` 只在本轮循环内有效，所以每一次循环的 `i` 其实都是一个新定义的变量，所以会输出当前 `i` 的值，每次循环对应输出。\n\n当然，这里可能会出现一个问题，每轮的变量都是一个新变量，那它是怎么知道上一轮循环的值的？稍做解释：[JS 引擎(v8)](https://jsshou.cn/blog/frontend/V8study.html#%E5%89%8D%E8%A8%80)内部会记住上一轮循环的值，初始化本轮的变量时，就在上一轮循环的基础上进行计算。\n\n上面我们说，`let` 命令在子代码块中也有效，可以从 `for` 循环上来看，`()` 内部其实就是一个父级作用域，而 `{}` 内部就是一个单独的子作用域。\n\n### 不存在变量提升\n\n变量提升，即变量可以在声明之前使用，值为 `undefined`，`var` 命令存在，而 `let` 命令并没有变量提升，照样，我们来看看使用的案例。\n\n```javascript\nconsole.log(a); // undefined\nvar a = 10;\n\nconsole.log(b); // ReferenceError\nlet b = 10;\n```\n\n可以在控制台中跑一下这段代码，进行尝试。你会发现，`a` 变量进行了变量提升，而 `b` 变量没有发生，这表明了在声明之前使用，变量 `b` 是不存在的。\n\n### 暂时性死区\n\n**代码块中，使用 `let` 命令声明变量之前，该变量都是不可用的**。\n\n在外部有一个全局变量 `x`，但是在内部使用 `let` 声明了一个 `x`，于是内部的 `x` 绑定了这个代码块，不受部影响。\n\n但是在内部，声明变量之前的这个区域就是**暂时性死区**，我们来从下面的代码来看。\n\n```javascript\nvar x = 100;\nif (true) {\n  // 暂时性死区 开始点\n  x = 10; // 报错\n  console.log(x); // 报错\n  let x; // 暂时性死区结束点\n  console.log(X); // undefined\n\n  x = 20;\n  console.log(x); // 20\n}\n```\n\n**暂时性死区**的存在，也就意味着 `typeof` 的操作会变的不安全，在没有声明变量时，使用 `typeof` 并不会报错，返回一个 `undefined`，然而因为暂时性死区，会使得 `typeof` 报错 `ReferenceError`。\n\n```javascript\nif (true) {\n  console.log(typeof x); // undefined\n  console.log(typeof y); // ReferenceError\n  let y;\n}\n```\n\n在[函数默认值](https://github.com/hzzzzzzzq/Blog/issues/6)中也存在暂时性死区，而且会不容易发现。\n\n```javascript\nfunction add(x = y, y = 1) {\n  return x + y;\n}\nadd(); // ReferenceError\n```\n\n在上面的代码中，就是如此，给[函数赋默认值](https://github.com/hzzzzzzzq/Blog/issues/6)时，使用后面的值赋值给前面的 `x`，而这时候 `y` 还没有定义，所以会报错。\n\n### 不允许重复声明\n\n`var` 变量是允许进行重复声明的，但是 `let` 变量是不允许的。\n\n来，上代码。\n\n```javascript\nvar a = 10;\nvar a = 20;\nconsole.log(a); // 20\n\nvar b = 10;\nlet b = 20;\nconsole.log(b); // 20\n\nlet c = 10;\nvar c = 20;\n// 报错\n\nlet d = 10;\nlet d = 20;\n// 报错\n```\n\n---\n\n## const 命令\n\n`const` 命令 声明一个只读的常量。一旦声明，常量的值就不能改变\n\n### 基本用法\n\n```javascript\nconst PI = 3.14159;\nconsole.log(PI); // 3.14159\n\nPI = 3.14; // TypeError: Assignment to constant variable\n```\n\n`const` 声明时，必须立即进行初始化，不能进行赋值。\n\n```javascript\ncosnt PI; // 报错 SyntaxError\n```\n\n`const` 只声明，不赋值就会报错。\n\n`const` 作用域与 `let` 相同：只在声明所在的块级作用域内有效。\n\n```javascript\n{\n  const PI = 3.14159;\n}\nconsole.log(PI); //Uncaught ReferenceError\n```\n\n`const` 命令也不存在变量提升，但是存在暂时性死区，只能在声明后使用。\n\n与 `let` 一样，不可进行重复声明。\n\n### 本质\n\n首先，我们来看一个对象的例子：\n\n```javascript\nconst obj = {};\nobj.prop = 1;\nconsole.log(obj.prop); // 1\n\nobj = {}; // TypeError\n```\n\n由上面可以看出，常量 `obj` 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 obj 指向另一个地址，但对象本身是可变的，所以依然可以添加新属性。\n\n再来看一个数组的例子：\n\n```javascript\nconst arr = [];\narr.push(1);\nconsole.log(arr); // 1\n\narr = [];\n```\n\n同对象，常量 `arr` 是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给 `arr`，就会报错。\n\n由此可见\n\n- `const` 保证的 实际上并不是变量的值不改动，而是变量指向的那个内存地址所保存的数据不得改动。\n\n- `const` 只能保证这个指针式固定的，至于他指向的数据结构是不是可变的，就完全不能控制了。\n","tags":["ES 6"],"categories":["ECMAScript 6"]},{"title":"ES 6 系列之了解ES 6","url":"/2022/01/18/Blog-ES-6-1-了解ES-6/","content":"\n首先呢，我们来说一下 `ECMAScript`，`ECMAScript` 是 `JavaScript` 中的语法规范。那我们来看看[**维基百科**中的定义](https://zh.wikipedia.org/wiki/ECMAScript)。\n\n> ECMAScript 是一种由 Ecma 国际（前身为欧洲计算机制造商协会）在标准 ECMA-262 中定义的脚本语言规范。这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMA-262 标准的实现和扩展。\n\n那 `ECMAScript` 的主要作用是什么呢？定义了很多我们需要使用的重要的东西。\n\n- 语法： 解析规则，关键词，语句，声明，操作等\n- 类型： 布尔型，数字，字符串，对象等\n- 原型和继承\n- 内置对象和函数的标准库： JSON，Math，数组方法等等\n\n说完了 `ECMAScript` ，那我们就可以来看看 `ES 6` 了。\n`ES 6` 全称 `ECMASCript 6`，我们可以看出，是 `ECMAScript` 的第六版，是 `JavaScript` 的一个标准， 2015 年 6 月发版，主要目的是解决 `ES 5` 的不足。截止 2020 年 6 月已经更新至 `11` 版。\n\n## 为什么要学习 ES 6？\n\n首先，`ES 6` 是 `ECMAScript 2015` 出版的一个标准，各个浏览器厂商都相当踊跃的遵循了这个标准，目前 **Chrome 已经支持了超过 80% 的 `ES 6` 特性**，业界流行框架类库都开始使用 `ES6` 编写。\n从 2011 年更新了 5.1 版本之后，直到 2015 年才更新了 `ES 6`， 它已成为 `JavaScript` 有史以来最实质的一次升级，新的语言和库特性就像无主之宝，等待有识之士的发掘。新的语言特性涵盖范围甚广，小到受欢迎的语法糖，例如箭头函数和简单的字符串插值，大到复杂的新概念，例如代理、生成器和承诺(`Promise`)等。\n`ES 6` 彻底改变了我们的编写 `JavaScript` 代码方式，况且目前 `ES 5` 的使用已经很少，基本上都采用了 `ES 6` 的写法。\n所以在这个复杂的前端时代，学习 `ES 6` 已经成为了必然。\n\n## 如何怎么学习？\n\n那我们来看看应该怎么学吧，我在接下来的文章中，将 `ES 6` 中重要的内容挖出来，并进行简单化教程，可以观看我之后的文章进行快速性学习，然后通过不断联系，去加快自己的掌握。\n","tags":["ES 6"],"categories":["ECMAScript 6"]}]